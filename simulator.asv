classdef simulator < handle
    
    properties (SetAccess = public)
        relationship; % calculate relationship between comps
        f = comp(1); % comps used to calcuate taylor series
        t ; % start time of each segment
        seg; % the last segment
        minResetTime = 0.05; % default minResetTime
        minOrder = 20; % default minOrder
    end
    
    methods        
        function created = simulator(initValue , initTime , relationship)
            created.t = initTime;
            created.relationship = relationship;
            for i = 1 : size(initValue, 2)
                created.f(i) = comp( initValue(i) );
            end
            created.seg = 1;
            created.addRelations(created.f, 1);
            created.repeatCompute(10);
        end
        
        function compute(this , time)
            u = time / this.minResetTime ;
            this.repeatCompute(this.minOrder);
            for x = 1 : u
                this.reset(this.minResetTime);
                this.repeatCompute(this.minOrder);
            end
        end
        
        function vv = func(this , tt)
            vv = tt ;
            segn = 1;
            upper = this.findThresh(1);
            for i = 1 : size(tt , 2)
                while tt(i) > upper
                    segn = segn + 1;
                    upper = this.findThresh(segn);
                end
                vv(i) = this.f(segn , 1).func(tt(i) - this.t(segn));
            end
        end
        
        function vv = deriv(this , tt , k)
            vv = tt ;
            segn = 1;
            upper = this.findThresh(1);
            for i = 1 : size(tt , 2)
                while tt(i) > upper
                    segn = segn + 1;
                    upper = this.findThresh(segn);
                end
                this.f(segn , 1)
                series = calcSeries( segn , tt(i) - this.t(segn) );
                vv(i) = series.taylor(k+1)*factorial(k);
%                 vv(i) = this.f(segn , 1).deriv( tt(i) - this.t(segn) , k );
            end
        end
        
        function plot(this , tt , compare)
            tts = min(tt): (max(tt)-min(tt))/70 : max(tt);
            plot( tt , this.func(tt) , '-'  , tts , compare(tts) , '.');             
        end
        
        function plotDeriv(this , tt , order)
            hold on
            plot( tt , this.deriv(tt , order) , 'y');             
        end
        
        function vv = converge(this, t, kk , answer)
            vv = kk;
            aa = kk;
            aa(:) = answer(t);
            for i = 1 : size(kk,2)
                k = kk(i);
                kt = k / t;
                v = (-1)^k / factorial(k) * (kt)^(k+1);
%                 v = (-1)^k / factorial(k) * (k/exp(1))^(k+1);
%                 v = (-1)^k / sqrt(2*pi*k) * (k/exp(1));
%                 v = v * (exp(1)/t)^(k+1) ;
%                 v = (-1)^k * (kt)^(k+1);
                x = this.deriv(kt , k);
                vv(i) = v * x;
            end
            plot(kk , vv ,'-', kk , aa , '.');
        end
        
    end
    
    
    
    methods (Access = private)
       function thresh = findThresh(this, seg)
            if size(this.t , 2) < seg + 1
                thresh = inf;
            else
                thresh = this.t(seg + 1);
            end
       end
       
       function addRelations(this, segComp , segn)
            for k = this.relationship
                comps = [];
                for j = k.comps
                    comps = [comps segComp(j)];
                end
                if k.order ~= 0
                    segComp(k.addTo).addR(k.coefficient*this.t(segn)^k.order , 0 ,  comps );
                end
                segComp(k.addTo).addR( k.coefficient, k.order ,  comps );
            end
       end
       
       function calcSeries(this, segn , leftDuration )
            newSegComp = this.f(1,:);
            for k = 1 : size( this.f , 2 )
                newSegComp(k) = comp( this.f(segn,k).func( leftDuration ) ) ;
            end
            this.addRelations(newSegComp , segn);
       end
       
       function reset(this , segDuration)
            resetTime = segDuration + this.t(this.seg);
            this.t = [this.t resetTime];
            newSegComp = this.f(1,:);
            for k = 1 : size( this.f , 2 )
                newSegComp(k) = comp( this.f(this.seg,k).func( resetTime - this.t(this.seg) ) ) ;
            end
            this.f = [this.f ; newSegComp];
            this.seg = this.seg + 1;
            this.addRelations(newSegComp, this.seg);  
     
       end
        
       function repeatCompute(this, order)
            for k = 1 : order
                for i = this.f(this.seg,:)
                    i.compute();
                end
            end
       end
    end
end